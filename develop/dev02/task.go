package main

import (
	"errors"
	"unicode"
)

/*
=== Задача на распаковку ===

Создать Go функцию, осуществляющую примитивную распаковку строки, содержащую повторяющиеся символы / руны, например:
	- "a4bc2d5e" => "aaaabccddddde"
	- "abcd" => "abcd"
	- "45" => "" (некорректная строка)
	- "" => ""
Дополнительное задание: поддержка escape - последовательностей
	- qwe\4\5 => qwe45 (*)
	- qwe\45 => qwe44444 (*)
	- qwe\\5 => qwe\\\\\ (*)

В случае если была передана некорректная строка функция должна возвращать ошибку. Написать unit-тесты.

Функция должна проходить все тесты. Код должен проходить проверки go vet и golint.
*/

// Функция, осуществляющая примитивную распаковку строки, содержащая повторяющиеся символы / руны
func UnpackString(str string) (string, error) {
	// Инициализация слайса рун для работы с каждым символом по отдельности
	var unpacked []rune
	// Инициализация флага обратного слеша
	var isSlash bool
	// Преобразование переданной строки в слайс рун
	runes := []rune(str)
	// Цикл по слайсу рун
	for i, val := range runes {
		// Если встретилась цифра и она была первой: возвращаем пустую строку и ошибку
		if i == 0 && unicode.IsDigit(val) {
			return "", errors.New("invalid string")
		}
		// Если уже встретчался обратный слеш и текущая руна - буква: возвращаем пустую строку и ошибку
		if isSlash && unicode.IsLetter(val) {
			return "", errors.New("invalid string")
		}
		// Если обратный слеш не встречался и текущая руна - обратный слеш: устанавливаем флаг слеша в истину
		if !isSlash && val == '\\' {
			isSlash = true
			continue
		}
		// Если \ уже встретчался обратный слеш: добавляем текущую руну в результат и сбрасываем флаг
		if isSlash {
			unpacked = append(unpacked, val)
			isSlash = false
			continue
		}
		// Если текущая руна - цифра: преобразовываем ее в интовое значение для подсчета количества добавлений
		if unicode.IsDigit(val) {
			times := val - '0'
			// Если это количество нулевое: удаляем предыдущую руну из результата
			if times == 0 {
				unpacked = unpacked[:len(unpacked)-1]
				continue
			}
			times--
			// Пока количество добавлений не станет равным нулю: добавляем предыдущую руну в результат
			for times != 0 {
				unpacked = append(unpacked, runes[i-1])
				times--
			}
			continue
		}
		// Если не попали ни в одно из условий, значит это были буквы, которые добавляем в результат
		unpacked = append(unpacked, val)
	}
	return string(unpacked), nil
}
