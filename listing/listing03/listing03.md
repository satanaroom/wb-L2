Что выведет программа? Объяснить вывод программы. Объяснить внутреннее устройство интерфейсов и их отличие от пустых интерфейсов.

```go
package main

import (
	"fmt"
	"os"
)

func Foo() error {
	var err *os.PathError = nil
	return err
}

func main() {
	err := Foo()
	fmt.Println(err)
	fmt.Println(err == nil)
}
```

Ответ:

```bash
<nil>
false
```

Значение интерфейса равно nil, только если его значение и динамический тип равны nil. В приведенном выше примере Foo() возвращает [nil, *os.PathError], и мы сравниваем его с [nil, nil].

Можно подумать о значении интерфейса nil как о типизированном, и nil без типа не равен nil с типом. Если мы конвертируем nil в правильный тип, значения действительно равны.

```go
fmt.Println(err == (*os.PathError)(nil)) // true
```

Чтобы избежать этой проблемы, необходимо использовать вместо этого переменную типа error, например именованное возвращаемое значение.
```go
func Foo() (err error) {
    // …
    // err не назначен и имеет нулевое значение [nil, nil]
    return
}

func main() {
    err := Foo()
    fmt.Println(err)        // <nil>
    fmt.Println(err == nil) // true
}
```
Лучше использовать встроенный тип интерфейса error, а не конкретный тип, для хранения и возврата значений ошибок.

Внутреннее устройство интерфейса следующее:

```go
type iface struct {
    tab  *itab
    data unsafe.Pointer
}
```
где tab — это указатель на Interface Table или itable — структуру, которая хранит некоторые метаданные о типе и список методов, используемых для удовлетворения интерфейса.
data — указывает на фактическую переменную с конкретным (статическим) типом.

Поскольку у пустого интерфейса нет никаких методов, то и itable для него просчитывать и хранить не нужно — достаточно только метаинформации о статическом типе.
- интерфейсы определяют поведение, статические типы — данные
- чем больше интерфейс, тем слабее абстракция
- интерфейс, как правило, создается потребителем.
